<html DIR="LTR" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:tool="http://www.microsoft.com/tooltip"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1252"></META><META NAME="save" CONTENT="history"></META><title>Heaps Stop Details</title><link rel="stylesheet" type="text/css" href="../local/Classic.css"></link><script src="../local/script.js"></script></head><body><div><input type="hidden" id="userDataCache" class="userDataStyle"></input><input type="hidden" id="hiddenScrollOffset"></input></div><img id="dropDownImage" style="display:none; height:0; width:0;" src="../local/drpdown.gif"></img><img id="dropDownHoverImage" style="display:none; height:0; width:0;" src="../local/drpdown_orange.gif"></img><img id="collapseImage" style="display:none; height:0; width:0;" src="../local/collapse.gif"></img><img id="expandImage" style="display:none; height:0; width:0;" src="../local/exp.gif"></img><img id="copyImage" style="display:none; height:0; width:0;" src="../local/copycode.gif"></img><img id="copyHoverImage" style="display:none; height:0; width:0;" src="../local/copycodeHighlight.gif"></img><div id="header"><table width="100%" id="topTable"><tr id="headerTableRow1"><td align="left"><span id="runningHeaderText"></span></td></tr><tr id="headerTableRow2"><td align="left"><span id="nsrTitle">Heaps Stop Details</span></td></tr><tr id="headerTableRow3"><td></td></tr></table></div><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()"></div><p>The Heap Verifier uses guard pages (or not depending on the properties selected) to check for memory corruption issues in the heap. Following is a list of verifier stops that may occur when running the Heap verifier against a solution or project on different platforms: </p><h3 class="subHeading"></h3><table><tr><td colspan="1"><p><b>Error message</b></p></td><td colspan="1"><p><b>Stop code</b></p></td></tr><tr><td colspan="1"><p><a href="6814118e-3e37-423a-a9db-ad154c77b93d.htm">Unknown Error (Heap)</a></p></td><td colspan="1"><p>0001</p></td></tr><tr><td colspan="1"><p><a href="373098cc-7f6b-42cd-b86e-95d1a21c8b32.htm">Access Violation Exception</a></p></td><td colspan="1"><p>0002</p></td></tr><tr><td colspan="1"><p><a href="2d22e735-f824-4ec8-8971-dd4c62fb1abb.htm">Multithreaded access in a heap created with HEAP_NO_SERIALIZE</a></p></td><td colspan="1"><p>0003</p></td></tr><tr><td colspan="1"><p><a href="ec7019cf-4410-458b-b039-d595fd433ea2.htm">Extreme size request</a></p></td><td colspan="1"><p>0004</p></td></tr><tr><td colspan="1"><p><a href="aa32efe0-221b-4005-99e7-cee1d48fdfec.htm">Heap handle with incorrect signature</a></p></td><td colspan="1"><p>0005</p></td></tr><tr><td colspan="1"><p><a href="ca7b25a9-f9f9-4095-b8d9-59bfb8b98f1c.htm">Corrupted heap pointer or using wrong heap</a></p></td><td colspan="1"><p>0006</p></td></tr><tr><td colspan="1"><p><a href="5de02cae-0ba3-4bc0-b006-6284157a4800.htm">Heap block already freed</a></p></td><td colspan="1"><p>0007</p></td></tr><tr><td colspan="1"><p><a href="d225aa50-b8de-437c-ad0f-417f07fe269a.htm">Corrupted heap block</a></p></td><td colspan="1"><p>0008</p></td></tr><tr><td colspan="1"><p><a href="46c6e12b-2c03-4540-9a93-824d155b89d7.htm">Attempt to destroy process heap</a></p></td><td colspan="1"><p>0009</p></td></tr><tr><td colspan="1"><p><a href="e8f46a06-c807-4d16-847a-2a0f00066204.htm">Unexpected exception raised while executing heap management code</a></p></td><td colspan="1"><p>000A</p></td></tr><tr><td colspan="1"><p><a href="a2a9d0be-35ea-4c28-8e07-17aef31b1fd2.htm">Exception raised while verifying heap block header</a></p></td><td colspan="1"><p>000B</p></td></tr><tr><td colspan="1"><p><a href="326c2ef9-efa3-41ef-a0e0-cdca04c75514.htm">Exception raised while verifying the heap block</a></p></td><td colspan="1"><p>000C</p></td></tr><tr><td colspan="1"><p><a href="87513329-300c-4d56-a48c-0e0dd367fb51.htm">Heap block corrupted after being freed</a></p></td><td colspan="1"><p>000D</p></td></tr><tr><td colspan="1"><p><a href="9445c703-3c53-45b2-ba19-76b576718af5.htm">Corrupted infix pattern for freed heap block</a></p></td><td colspan="1"><p>000E</p></td></tr><tr><td colspan="1"><p><a href="71af3676-235a-46b1-92e1-3a0c4e473b70.htm">Corrupted suffix pattern for heap block</a></p></td><td colspan="1"><p>000F</p></td></tr><tr><td colspan="1"><p><a href="d02cdd8e-1642-4744-b6f4-68b96d45aca8.htm">Corrupted start stamp for heap block</a></p></td><td colspan="1"><p>0010</p></td></tr><tr><td colspan="1"><p><a href="008cf527-6ac5-47ea-9923-9f714e1bcdc5.htm">Corrupted end stamp for heap block</a></p></td><td colspan="1"><p>0011</p></td></tr><tr><td colspan="1"><p><a href="81a3c3ba-8efb-49ac-a2dd-a9e12dce9b3d.htm">Corrupted prefix pattern for heap block</a></p></td><td colspan="1"><p>0012</p></td></tr><tr><td colspan="1"><p><a href="9aa3c90b-2f12-40e6-a68f-02a1af9121d2.htm">First chance access violation for current stack trace</a></p></td><td colspan="1"><p>0013</p></td></tr><tr><td colspan="1"><p><a href="0970bae7-faea-4e28-bfc2-6c8e250fc2e6.htm">Invalid process heap list count</a></p></td><td colspan="1"><p>0014</p></td></tr></table><p></p><h2 class="heading">System Requirements</h2><div id="sectionSection0" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns=""> The Page Heap test uses guard pages to detect memory corruption issues in the heap. To gain the most useful information from this test, the computer should contain at least 256MB of RAM and have a 1GB page file.</p></content></div><h2 class="heading">Properties</h2><div id="sectionSection1" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns="">There are several properties for the Heaps check that can be altered:</p><ul xmlns=""><li class="unordered">
							Full – Check to implement full page heap. If unselect it’s normal page heap<br /><br /></li><li class="unordered">
							Dlls - Page heap allocations for target dlls only. Name of the binaries with extension (dll or something else). If you wish to enter in more than one, enter a space between the dll names.<br /><br /></li><li class="unordered">
							Size - Page heap allocations for size range. Specify the size range in the Size Start and Size End.<br /><br /></li><li class="unordered">
							SizeStart - Beginning of the size range<br /><br /></li><li class="unordered">
							SizeEnd - Ending of the size range. <br /><br /></li><li class="unordered">
							Random - Page heap allocations with probability. If selected, you need to enter in a RandRate.<br /><br /></li><li class="unordered">
							RandRate - Decimal integer in range [0..100] representing probability to make page heap allocation vs. a normal heap allocation.<br /><br /></li><li class="unordered">
							Backward - Catch backwards overruns. If selected, this will check buffer underruns.<br /><br /></li><li class="unordered">
							Unalign - No alignment for allocations.<br /><br /></li><li class="unordered">
							Traces - Collect stack traces<br /><br /></li><li class="unordered">
							Protect - Protect heap internal structures. Can be used to detect random corruptions but execution is slower. Note that this is turned off by default and should only be set to True by an advanced user who knows how to debug the problems that it may uncover.<br /><br /></li><li class="unordered">
							NoLock - Disable critical section verifier.<br /><br /></li><li class="unordered">
							Faults – Enable heap fault injection. Note that the preferred method for running fault injection is the Low Resource Simulation Stops.<br /><br /></li><li class="unordered">
							FaultRate - Probability (1..10000) for heap calls failures<br /><br /></li><li class="unordered">
							TimeOut - Time during process initialization (in milliseconds) when faults are not allowed.<br /><br /></li><li class="unordered">
							Addr - Page heap allocations for address range. If selected, please specify the address range in AddrStart and AddrEnd.<br /><br /></li><li class="unordered">
							AddrStart - Beginning of the address range<br /><br /></li><li class="unordered">
							AddrEnd - Ending of the address range<br /><br /></li><li class="unordered">
							UseLFHGuardPage - Turns on LFH guard pages, which is turned off by default.<br /><br /></li><li class="unordered">
							DelayFreeSize (MB) - Maximum amount of memory, in megabytes, to use for delayed free list. The Heap Verifier checks this list to detect double freeing of an allocation and the use of an allocation after it has been freed. The default value of this property varies by processor architecture.<br /><br /></li></ul></content></div><h2 class="heading">Additional information</h2><div id="sectionSection2" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns=""> Heap detects almost any heap related bug that is detectable. It is focused on corruption issues and not on leaks. The Page Heap tests in Application Verifier are not able to capture information about most heap memory leaks, so a different tool would be useful for that category of heap problem. </p><p xmlns="">One of the great advantages of the Page Heap test in Application Verifier is that many errors can be detected in the instant they happen. For example, an off by one byte error at the end of a dynamically allocated buffer might cause an instant access violation. However, there are a few error categories that cannot be detected instantly and the error report is delayed until the block is freed. </p><p xmlns="">The Page Heap functionality provides the following tests to Application Verifier: </p><ul xmlns=""><li class="unordered">
							Invalid heap pointer - All Microsoft Win32 and NT level heap interfaces take as first parameter a pointer to the heap where the operation should happen. The page heap manager detects at the moment of the call an invalid heap pointer. <br /><br /></li><li class="unordered">
							Invalid heap block pointer - After a block is allocated it can be used as a parameter for several heap interfaces (most notably free() class of interfaces). The page heap manager detects immediately an invalid heap block pointer. See the debugging techniques section for a way to determine if the invalid address is just meaningless information or is a few bytes off. <br /><br /></li><li class="unordered">
							Multithreaded unsynchronized access to the heap - some applications call into a heap from multiple threads. This type of scenario requires setting a flag (by the user) that triggers acquiring a heap lock. The page heap manager detects this type of violation in the moment two threads attempt to call simultaneously into the heap. <br /><br /></li><li class="unordered">
							Assumptions about reallocation of a block at the same address - Although it is thoroughly documented that a reallocation operation is not guaranteed to return the same address, once in a while applications contain this assumption. This is especially the case when the reallocation reduces the size of the block. The page heap manager always allocates a new block during a reallocation and frees the old block. The free block is protected for R/W access and therefore any access to it raises an access violation. <br /><br /></li><li class="unordered">
							Double free - It is a bug noticed with high frequency. Heap blocks are freed several times. This is detected immediately by the page heap manager because on the second free the block does not have the proper prefix header and cannot be found among the allocated blocks. See the debugging techniques section for ways to figure out the stack trace of the first free operation. This error can be a variant of the reallocation problem because when the application frees what it thinks is the address of the block, that block was already freed as part of the reallocation. <br /><br /></li><li class="unordered">
							Access of block after free - The memory blocks freed are kept for a while by the page heap manager in a pool of protected memory. Any access to such a block raises an access violation. Based on the "locality" principle, it is expected to catch most of the problems if the free protected pool is large enough. If the freed block is still in the protected pool then the bug is caught instantly. If the memory was reused, the chances of finding the bug decrease considerably. <br /><br /></li><li class="unordered">
							Access after the end of allocated block - The page heap manager places an inaccessible page right after the allocated block. Any access after the end of the block raises an access violation. There is one little caveat. Some applications (for example, Microsoft Internet Explorer) expect allocations to be 8-byte aligned. This is a feature supported since the heap manager in Microsoft Windows NT 3.5. This means that a request size that is not 8-byte aligned gets an 8-byte aligned address and this leaves a few bytes after the end of the block that are still accessible. If the application corrupts only those few bytes then the error is caught only when the block gets freed by checking the block suffix pattern. <br /><br /></li><li class="unordered">
							Access before the start of allocated block - The page heap manager can be instructed through setting a flag to place the inaccessible page at the beginning rather than at the end of the block. Any access before the start of the block raises an access violation.<br /><br /></li></ul><p xmlns="">For more information, see the <a href="34451313-e78e-46bb-a01b-6c04a6da216d.htm">Heap details</a> topic.</p></content></div><!--[if gte IE 5]>
			<tool:tip element="languageFilterToolTip" avoidmouse="false"/>
		<![endif]--></div><div id="footer"><p></p><hr></hr><br /><br /></div></div></body></html>