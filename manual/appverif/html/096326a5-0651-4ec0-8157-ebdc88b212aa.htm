<html DIR="LTR" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:tool="http://www.microsoft.com/tooltip"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1252"></META><META NAME="save" CONTENT="history"></META><title>Debugging Heap Errors</title><link rel="stylesheet" type="text/css" href="../local/Classic.css"></link><script src="../local/script.js"></script></head><body><div><input type="hidden" id="userDataCache" class="userDataStyle"></input><input type="hidden" id="hiddenScrollOffset"></input></div><img id="dropDownImage" style="display:none; height:0; width:0;" src="../local/drpdown.gif"></img><img id="dropDownHoverImage" style="display:none; height:0; width:0;" src="../local/drpdown_orange.gif"></img><img id="collapseImage" style="display:none; height:0; width:0;" src="../local/collapse.gif"></img><img id="expandImage" style="display:none; height:0; width:0;" src="../local/exp.gif"></img><img id="copyImage" style="display:none; height:0; width:0;" src="../local/copycode.gif"></img><img id="copyHoverImage" style="display:none; height:0; width:0;" src="../local/copycodeHighlight.gif"></img><div id="header"><table width="100%" id="topTable"><tr id="headerTableRow1"><td align="left"><span id="runningHeaderText"></span></td></tr><tr id="headerTableRow2"><td align="left"><span id="nsrTitle">Debugging Heap Errors</span></td></tr><tr id="headerTableRow3"><td></td></tr></table></div><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()"></div><h2 class="heading">The heap verifier debugger extension</h2><div id="sectionSection0" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns="">The heap verifier debugger extension is part of the !heap extension (NT heap debugger extension). Simple help can be obtained with !heap -? or more extensive with !heap -p -? <code>.</code> The current extension does not detect on its own if page heap is enabled for a process and act accordingly. For now the user of the extension needs to know that page heap is enabled and use commands prefixed by !heap -p .</p><p xmlns="">!heap -p</p><p xmlns="">Dumps addresses of all full page heaps created in the process.</p><p xmlns="">!heap -p -h ADDRESS-OF-HEAP</p><p xmlns="">Full dump of full page heap at ADDRESS-OF-HEAP.</p><p xmlns="">!heap -p -a ADDRESS</p><p xmlns="">Tries to figure out if there is a heap block at ADDRESS. This value does not need to be the address of the start of the block. The command is useful if there is no clue whatsoever about the nature of a memory area.</p></content></div><h2 class="heading">Heap operation log</h2><div id="sectionSection1" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns="">The heap operation log tracks all heap routines. These include HeapAlloc, HeapReAlloc, and HeapFree.</p><p xmlns="">You can use the !avrf -hp Length extension command to display the last several records; Length specifies the number of records.</p><p xmlns="">You can use !avrf -hp -a Address to display all heap space operations that affected the specified Address. For an allocation operation, it is sufficient that Address be contained in the allocated heap block. For a free operation, the exact address of the beginning of the block must be given.</p><p xmlns="">For each entry in the log, the following information is displayed:</p><p xmlns="">The heap function called. </p><p xmlns="">The thread ID of the thread that called the routine. </p><p xmlns="">The address involved in the call — this is the address that was returned by an allocation routine or that was passed to a free routine. </p><p xmlns="">The size of the region involved in the call. </p><p xmlns="">The stack trace of the call. </p><p xmlns="">The most recent entries are displayed first.</p><p xmlns="">In this example, the two most recent entries are displayed:</p><p xmlns="">0:001&gt; !avrf -hp 2</p><p xmlns="">alloc (tid: 0xFF4): </p><p xmlns="">address: 00ea2fd0 </p><p xmlns="">size: 00001030</p><p xmlns="">        00403062: Prymes!_heap_alloc_dbg+0x1A2</p><p xmlns="">        00402e69: Prymes!_nh_malloc_dbg+0x19</p><p xmlns="">        00402e1e: Prymes!_malloc_dbg+0x1E</p><p xmlns="">        00404ff3: Prymes!_stbuf+0xC3</p><p xmlns="">        00401c23: Prymes!printf+0x43</p><p xmlns="">        00401109: Prymes!main+0xC9</p><p xmlns="">        00402039: Prymes!mainCRTStartup+0xE9</p><p xmlns="">        77e7a278: kernel32!BaseProcessStart+0x23</p><p xmlns="">alloc (tid: 0xFF4): </p><p xmlns="">address: 00ea07d0 </p><p xmlns="">size: 00000830</p><p xmlns="">        00403062: Prymes!_heap_alloc_dbg+0x1A2</p><p xmlns="">        00402e69: Prymes!_nh_malloc_dbg+0x19</p><p xmlns="">        00402e1e: Prymes!_malloc_dbg+0x1E</p><p xmlns="">        00403225: Prymes!_calloc_dbg+0x25</p><p xmlns="">        00401ad5: Prymes!__initstdio+0x45</p><p xmlns="">        00401f38: Prymes!_initterm+0x18</p><p xmlns="">        00401da1: Prymes!_cinit+0x21</p><p xmlns="">        00402014: Prymes!mainCRTStartup+0xC4</p><p xmlns="">        77e7a278: kernel32!BaseProcessStart+0x23</p></content></div><h2 class="heading">Typical debug scenarios</h2><div id="sectionSection2" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns="">There are several failure scenarios that might be encountered. Some of them require quite a bit of detective work to get the whole picture.</p></content></div><h2 class="heading">Access violation in non-accessible page</h2><div id="sectionSection3" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns="">This happens when full page heap is enabled if the tested application accesses beyond the end of buffer. It can also happen if it touches a freed block. In order to understand what is the nature of the address on which the exception occurred, you need to use:</p><p xmlns="">            !heap –p –a ADDRESS-OF-AV</p></content></div><h2 class="heading">Corrupted block message</h2><div id="sectionSection4" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns="">At several moments during the lifetime of an allocation (allocation, user free, real free) the page heap manager checks if the block has all fill patterns intact and the block header has consistent data. If this is not the case you will get a verifier stop. </p><p xmlns="">If the block is a full page heap block (for example, if you know for sure full page heap is enabled for all allocations) then you can use “!heap –p –a ADDRESS” to find out what are the characteristics of the block. </p><p xmlns="">If the block is a light page heap block then you need to find out the start address for the block header. You can find the start address by dumping 30-40 bytes below the reported address and look for the magic start/end patterns for a block header (ABCDAAAA, ABCDBBBB, ABCDAAA9, ABCDBBBA). </p><p xmlns="">The header will give all the information you need to understand the failure. Particularly, the magic patterns will tell if the block is allocated or free if it is a light page heap or a full page heap block. The information here has to be matched carefully with the offending call. </p><p xmlns="">For example if a call to HeapFree is made with the address of a block plus four bytes, then you will get the corrupted message. The block header will look fine but you will have to notice that the first byte after the end of the header (first byte after 0xDCBAXXXX magic value) has a different address then the one in the call.</p></content></div><h2 class="heading">Special fill pointers</h2><div id="sectionSection5" class="section"><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"><p xmlns="">The page heap manager fills the user allocation with values that will look as kernel pointers. This happens when the block gets freed (fill value is F0) and when the block gets allocated but no request is made for the block to be zeroed (fill value is E0 for light page heap and C0 for full page heap). The non-zeroed allocations are typical for malloc/new users. If there is a failure (access violation) where a read/write is attempted at addresses like F0F0F0F0, E0E0E0E0, C0C0C0C0 then most probably you hit one of these cases. </p><p xmlns="">A read/write at F0F0F0F0 means a block has been used after it got freed. Unfortunately you will need some detective work to find out which block caused this. You need to get the stack trace of the failure and then inspect the code for the functions on the stack. One of them might make a wrong assumption about an allocation being alive.</p><p xmlns="">A read/write at E0E0E0E0/C0C0C0C0 means the application did not initialize properly the allocation. This also requires code inspection of the functions in the current stack trace. Here it is an example for this kind of failure. In a test process an access violation while doing a HeapFree on address E0E0E0E0 was noticed. It turned out that the test allocated a structure, did not initialize it correctly and then called the destructor of the object. Since a certain field was not null (it had E0E0E0E0 in it) it called delete on it.</p></content></div><!--[if gte IE 5]>
			<tool:tip element="languageFilterToolTip" avoidmouse="false"/>
		<![endif]--></div><div id="footer"><p></p><hr></hr><br /><br /></div></div></body></html>